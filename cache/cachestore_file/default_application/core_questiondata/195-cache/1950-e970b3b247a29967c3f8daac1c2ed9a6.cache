O:8:"stdClass":27:{s:2:"id";s:4:"1950";s:8:"category";s:3:"326";s:6:"parent";s:1:"0";s:4:"name";s:6:"Q51-15";s:12:"questiontext";s:296:"<p>In a supply chain network, warehouses and distribution centers are represented as nodes, and transportation routes are edges with travel times. Given a starting warehouse, how would you determine which distribution centers are unreachable using Dijkstra's algorithm? <strong>[IBM]</strong></p>";s:18:"questiontextformat";s:1:"1";s:15:"generalfeedback";s:0:"";s:21:"generalfeedbackformat";s:1:"1";s:11:"defaultmark";d:1;s:7:"penalty";d:0;s:5:"qtype";s:10:"coderunner";s:6:"length";s:1:"1";s:5:"stamp";s:37:"lms.velandev.life+250824050414+XjmZDd";s:11:"timecreated";s:10:"1756011854";s:12:"timemodified";s:10:"1756011854";s:9:"createdby";s:1:"2";s:10:"modifiedby";s:1:"2";s:8:"idnumber";N;s:9:"contextid";s:3:"455";s:6:"status";s:5:"ready";s:9:"versionid";s:4:"1950";s:7:"version";s:1:"1";s:19:"questionbankentryid";s:4:"1936";s:14:"categoryobject";O:8:"stdClass":9:{s:2:"id";s:3:"326";s:4:"name";s:23:"M5-D1- Coding Challenge";s:9:"contextid";s:3:"455";s:4:"info";s:0:"";s:10:"infoformat";s:1:"0";s:5:"stamp";s:37:"lms.velandev.life+250824050414+WQ68Dr";s:6:"parent";s:3:"324";s:9:"sortorder";s:3:"999";s:8:"idnumber";N;}s:7:"options";O:8:"stdClass":46:{s:14:"coderunnertype";s:6:"nodejs";s:13:"prototypetype";s:1:"0";s:12:"allornothing";s:1:"1";s:13:"penaltyregime";s:1:"0";s:8:"precheck";s:1:"0";s:9:"hidecheck";s:1:"0";s:10:"showsource";s:1:"0";s:14:"answerboxlines";s:2:"18";s:16:"answerboxcolumns";s:3:"100";s:13:"answerpreload";s:2238:"class MinPriorityQueue {
    constructor(comparator = (a, b) => a[1] - b[1]) {
        this.heap = [];
        this.comparator = comparator;
    }

    enqueue(item) {
        this.heap.push(item);
        this._heapifyUp();
    }

    dequeue() {
        const item = this.heap[0];
        const end = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = end;
            this._heapifyDown();
        }
        return item;
    }

    isEmpty() {
        return this.heap.length === 0;
    }

    _heapifyUp() {
        let index = this.heap.length - 1;
        const item = this.heap[index];
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            const parent = this.heap[parentIndex];
            if (this.comparator(item, parent) >= 0) break;
            this.heap[index] = parent;
            index = parentIndex;
        }
        this.heap[index] = item;
    }

    _heapifyDown() {
        let index = 0;
        const length = this.heap.length;
        const item = this.heap[index];

        while (true) {
            let leftIndex = 2 * index + 1;
            let rightIndex = 2 * index + 2;
            let left, right;
            let swapIndex = null;

            if (leftIndex < length) {
                left = this.heap[leftIndex];
                if (this.comparator(left, item) < 0) {
                    swapIndex = leftIndex;
                }
            }

            if (rightIndex < length) {
                right = this.heap[rightIndex];
                if (
                    (swapIndex === null && this.comparator(right, item) < 0) ||
                    (swapIndex !== null && this.comparator(right, left) < 0)
                ) {
                    swapIndex = rightIndex;
                }
            }

            if (swapIndex === null) break;
            this.heap[index] = this.heap[swapIndex];
            index = swapIndex;
        }
        this.heap[index] = item;
    }
}
function dijkstra(adjList, source) {
    /* Type your code here */
}


function findUnreachableCenters(adjList, startingWarehouse) {
    /* Type your code here */
}";s:11:"globalextra";s:0:"";s:6:"useace";s:1:"1";s:13:"resultcolumns";N;s:8:"template";s:188:"{{ STUDENT_ANSWER }}

var SEPARATOR = "#<ab@17943918#@>#";

{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
console.log(SEPARATOR);
{% endif %}
{% endfor %}";s:20:"iscombinatortemplate";s:1:"1";s:19:"allowmultiplestdins";s:1:"0";s:6:"answer";s:3060:"class MinPriorityQueue {
    constructor(comparator = (a, b) => a[1] - b[1]) {
        this.heap = [];
        this.comparator = comparator;
    }

    enqueue(item) {
        this.heap.push(item);
        this._heapifyUp();
    }

    dequeue() {
        const item = this.heap[0];
        const end = this.heap.pop();
        if (this.heap.length > 0) {
            this.heap[0] = end;
            this._heapifyDown();
        }
        return item;
    }

    isEmpty() {
        return this.heap.length === 0;
    }

    _heapifyUp() {
        let index = this.heap.length - 1;
        const item = this.heap[index];
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            const parent = this.heap[parentIndex];
            if (this.comparator(item, parent) >= 0) break;
            this.heap[index] = parent;
            index = parentIndex;
        }
        this.heap[index] = item;
    }

    _heapifyDown() {
        let index = 0;
        const length = this.heap.length;
        const item = this.heap[index];

        while (true) {
            let leftIndex = 2 * index + 1;
            let rightIndex = 2 * index + 2;
            let left, right;
            let swapIndex = null;

            if (leftIndex < length) {
                left = this.heap[leftIndex];
                if (this.comparator(left, item) < 0) {
                    swapIndex = leftIndex;
                }
            }

            if (rightIndex < length) {
                right = this.heap[rightIndex];
                if (
                    (swapIndex === null && this.comparator(right, item) < 0) ||
                    (swapIndex !== null && this.comparator(right, left) < 0)
                ) {
                    swapIndex = rightIndex;
                }
            }

            if (swapIndex === null) break;
            this.heap[index] = this.heap[swapIndex];
            index = swapIndex;
        }
        this.heap[index] = item;
    }
}
function dijkstra(adjList, source) {
    const n = adjList.length;
    const dist = Array(n).fill(Infinity);
    const visited = Array(n).fill(false);
    const pq = new MinPriorityQueue();

    dist[source] = 0;
    pq.enqueue([source, 0]);

    while (!pq.isEmpty()) {
        const [u, uDist] = pq.dequeue();
        if (visited[u]) continue;
        visited[u] = true;

        for (const [v, weight] of adjList[u]) {
            if (!visited[v] && uDist + weight < dist[v]) {
                dist[v] = uDist + weight;
                pq.enqueue([v, dist[v]]);
            }
        }
    }

    return dist;
}


function findUnreachableCenters(adjList, startingWarehouse) {
    const distances = dijkstra(adjList, startingWarehouse);
    const unreachableCenters = [];
    
    distances.forEach((distance, index) => {
        if (distance === Infinity) {
            unreachableCenters.push(index);
        }
    });

    return unreachableCenters;
}";s:14:"validateonsave";s:1:"1";s:14:"testsplitterre";s:23:"|#<ab@17943918#@>#\n|ms";s:8:"language";s:6:"nodejs";s:7:"acelang";N;s:7:"sandbox";N;s:6:"grader";s:14:"EqualityGrader";s:16:"cputimelimitsecs";N;s:10:"memlimitmb";s:4:"1000";s:13:"sandboxparams";s:35:"{"sourcefilename": "__tester__.js"}";s:14:"templateparams";s:0:"";s:19:"hoisttemplateparams";s:1:"1";s:19:"extractcodefromjson";s:1:"1";s:18:"templateparamslang";s:4:"None";s:24:"templateparamsevalpertry";s:1:"0";s:19:"templateparamsevald";s:2:"{}";s:7:"twigall";s:1:"0";s:8:"uiplugin";s:3:"ace";s:12:"uiparameters";s:0:"";s:11:"attachments";s:1:"0";s:19:"attachmentsrequired";s:1:"0";s:11:"maxfilesize";s:5:"10240";s:14:"filenamesregex";s:0:"";s:16:"filenamesexplain";s:0:"";s:15:"displayfeedback";s:1:"1";s:13:"giveupallowed";s:1:"0";s:14:"prototypeextra";N;s:7:"answers";a:0:{}s:9:"customise";b:1;s:9:"testcases";a:5:{i:0;O:8:"stdClass":11:{s:2:"id";s:4:"1174";s:10:"questionid";s:4:"1950";s:8:"testtype";s:1:"0";s:8:"testcode";s:336:"const adjList = [
    [[1, 10], [2, 20]],
    [[0, 10], [2, 5], [3, 15]],
    [[0, 20], [1, 5], [3, 10]],
    [[1, 15], [2, 10]],
    [[5, 5]],
    [[4, 5]]];
const startingWarehouse = 0;
const unreachableCenters = findUnreachableCenters(adjList, startingWarehouse);
console.log('Unreachable distribution centers:', unreachableCenters);";s:5:"stdin";s:0:"";s:8:"expected";s:42:"Unreachable distribution centers: [ 4, 5 ]";s:5:"extra";s:0:"";s:12:"useasexample";s:1:"1";s:7:"display";s:4:"SHOW";s:14:"hiderestiffail";s:1:"0";s:4:"mark";s:5:"1.000";}i:1;O:8:"stdClass":11:{s:2:"id";s:4:"1175";s:10:"questionid";s:4:"1950";s:8:"testtype";s:1:"0";s:8:"testcode";s:284:"const adjList = [
    [[1, 3], [2, 5]],
    [[0, 3], [3, 7]],
    [[0, 5], [3, 1]],
    [[1, 7], [2, 1]]];
const startingWarehouse = 0;
const unreachableCenters = findUnreachableCenters(adjList, startingWarehouse);
console.log('Unreachable distribution centers:', unreachableCenters);";s:5:"stdin";s:0:"";s:8:"expected";s:36:"Unreachable distribution centers: []";s:5:"extra";s:0:"";s:12:"useasexample";s:1:"0";s:7:"display";s:4:"SHOW";s:14:"hiderestiffail";s:1:"0";s:4:"mark";s:5:"1.000";}i:2;O:8:"stdClass":11:{s:2:"id";s:4:"1176";s:10:"questionid";s:4:"1950";s:8:"testtype";s:1:"0";s:8:"testcode";s:268:"const adjList = [
    [[1, 4]],
    [[0, 4], [3, 1]],
    [[0, 2], [3, 3]],
    [[1, 1]]];
const startingWarehouse = 1;
const unreachableCenters = findUnreachableCenters(adjList, startingWarehouse);
console.log('Unreachable distribution centers:', unreachableCenters);";s:5:"stdin";s:0:"";s:8:"expected";s:40:"Unreachable distribution centers: [ 2 ]
";s:5:"extra";s:0:"";s:12:"useasexample";s:1:"0";s:7:"display";s:4:"SHOW";s:14:"hiderestiffail";s:1:"0";s:4:"mark";s:5:"1.000";}i:3;O:8:"stdClass":11:{s:2:"id";s:4:"1177";s:10:"questionid";s:4:"1950";s:8:"testtype";s:1:"0";s:8:"testcode";s:285:"const adjList = [
    [[1, 3], [2, 1]],
    [[0, 3], [3, 5]],
    [[0, 1], [3, 2]],
    [[1, 5], [2, 2]]];
const startingWarehouse = 3;
const unreachableCenters = findUnreachableCenters(adjList, startingWarehouse);
console.log('Unreachable distribution centers: ', unreachableCenters);";s:5:"stdin";s:0:"";s:8:"expected";s:37:"Unreachable distribution centers:  []";s:5:"extra";s:0:"";s:12:"useasexample";s:1:"0";s:7:"display";s:4:"HIDE";s:14:"hiderestiffail";s:1:"0";s:4:"mark";s:5:"1.000";}i:4;O:8:"stdClass":11:{s:2:"id";s:4:"1178";s:10:"questionid";s:4:"1950";s:8:"testtype";s:1:"0";s:8:"testcode";s:285:"const adjList = [
    [[1, 3], [2, 1]],
    [[0, 3], [3, 5]],
    [[0, 1], [3, 2]],
    [[1, 5], [2, 2]]];
const startingWarehouse = 1;
const unreachableCenters = findUnreachableCenters(adjList, startingWarehouse);
console.log('Unreachable distribution centers: ', unreachableCenters);";s:5:"stdin";s:0:"";s:8:"expected";s:37:"Unreachable distribution centers:  []";s:5:"extra";s:0:"";s:12:"useasexample";s:1:"0";s:7:"display";s:4:"HIDE";s:14:"hiderestiffail";s:1:"0";s:4:"mark";s:5:"1.000";}}}s:5:"hints";a:0:{}s:9:"prototype";O:25:"qtype_coderunner_question":86:{s:2:"id";s:4:"2785";s:8:"category";s:1:"2";s:9:"contextid";s:1:"1";s:6:"parent";s:1:"0";s:5:"qtype";O:16:"qtype_coderunner":1:{s:14:" * fileoptions";a:3:{s:7:"subdirs";b:1;s:8:"maxfiles";i:-1;s:8:"maxbytes";i:0;}}s:4:"name";s:24:"BUILTIN_PROTOTYPE_nodejs";s:12:"questiontext";s:536:"<p>A JavaScript question type, run using nodejs. The
test program to be executed starts with the student answer. That is followed
by each of the test case codes in turn, with a separator string being printed
between them. However, if there is any standard input present for any of the
test cases, a separate test run will be done for each test case.</p><p>
If there is a risk of side-effects from a test case affecting later test cases
you can add standard input to any one of the test cases to force the one-run-per-test-case
mode.</p>";s:18:"questiontextformat";s:1:"1";s:15:"generalfeedback";s:0:"";s:21:"generalfeedbackformat";s:1:"1";s:11:"defaultmark";d:1;s:6:"length";s:1:"1";s:7:"penalty";d:0;s:5:"stamp";s:37:"lms.velandev.life+250922115904+0z8ofh";s:8:"idnumber";N;s:11:"timecreated";s:10:"1758542344";s:12:"timemodified";s:10:"1758542344";s:9:"createdby";s:1:"2";s:10:"modifiedby";s:1:"2";s:5:"hints";a:0:{}s:6:"status";s:5:"ready";s:9:"versionid";s:4:"2785";s:7:"version";s:1:"1";s:19:"questionbankentryid";s:4:"2771";s:16:" * latestversion";N;s:12:"customfields";a:0:{}s:14:"shownumcorrect";b:0;s:9:"testcases";a:0:{}s:14:"coderunnertype";s:6:"nodejs";s:13:"prototypetype";s:1:"1";s:12:"allornothing";s:1:"1";s:13:"penaltyregime";s:15:"33.3, 66.7, ...";s:8:"precheck";s:1:"0";s:9:"hidecheck";s:1:"0";s:10:"showsource";s:1:"0";s:14:"answerboxlines";s:2:"18";s:13:"answerpreload";s:0:"";s:11:"globalextra";s:0:"";s:6:"useace";s:1:"1";s:13:"resultcolumns";N;s:8:"template";s:179:"{{ STUDENT_ANSWER }}

var SEPARATOR = "#<ab@17943918#@>#";

{% for TEST in TESTCASES %}
{{ TEST.testcode }}
{% if not loop.last %}
console.log(SEPARATOR);
{% endif %}
{% endfor %}";s:20:"iscombinatortemplate";s:1:"1";s:19:"allowmultiplestdins";s:1:"0";s:6:"answer";s:0:"";s:14:"validateonsave";s:1:"0";s:14:"testsplitterre";s:23:"|#<ab@17943918#@>#\n|ms";s:8:"language";s:6:"nodejs";s:7:"acelang";N;s:7:"sandbox";N;s:6:"grader";s:14:"EqualityGrader";s:16:"cputimelimitsecs";N;s:10:"memlimitmb";s:4:"1000";s:13:"sandboxparams";s:35:"{"sourcefilename": "__tester__.js"}";s:14:"templateparams";s:0:"";s:19:"hoisttemplateparams";s:1:"0";s:19:"extractcodefromjson";s:1:"1";s:18:"templateparamslang";s:4:"twig";s:24:"templateparamsevalpertry";s:1:"0";s:19:"templateparamsevald";s:0:"";s:7:"twigall";s:1:"0";s:8:"uiplugin";s:3:"ace";s:12:"uiparameters";s:0:"";s:11:"attachments";s:1:"0";s:19:"attachmentsrequired";s:1:"0";s:11:"maxfilesize";s:1:"0";s:14:"filenamesregex";s:0:"";s:16:"filenamesexplain";s:0:"";s:15:"displayfeedback";s:1:"0";s:13:"giveupallowed";s:1:"0";s:14:"prototypeextra";N;s:7:"answers";a:0:{}s:9:"customise";b:1;s:7:"student";N;s:9:"prototype";N;s:26:"initialisationerrormessage";N;s:16:"cachedfuncparams";N;s:25:"cachedevaldtemplateparams";N;s:18:"mergeduiparameters";N;s:18:"templateparamsjson";N;s:10:"parameters";N;s:8:"stepinfo";N;s:7:"options";N;s:5:"isnew";N;s:7:"context";N;s:10:"questionid";N;s:16:"answerboxcolumns";s:3:"100";}}